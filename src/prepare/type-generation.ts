import { normalize, relative, resolve } from 'pathe'
import { addServerHandler, addTypeTemplate, addVitePlugin, isIgnored, updateTemplates, useNitro } from '@nuxt/kit'
import { watch as chokidarWatch } from 'chokidar'

import type { Nuxt } from '@nuxt/schema'
import type { I18nOptions } from 'vue-i18n'
import type { I18nNuxtContext } from '../context'

/**
 * Simplifies messages object to properties of an interface
 */
function generateInterface(obj: Record<string, unknown>, indentLevel = 1) {
  const indent = '  '.repeat(indentLevel)
  let str = ''

  for (const key in obj) {
    if (!Object.prototype.hasOwnProperty.call(obj, key)) continue

    if (typeof obj[key] === 'object' && obj[key] !== null && !Array.isArray(obj[key])) {
      str += `${indent}"${key}": {\n`
      str += generateInterface(obj[key] as Record<string, unknown>, indentLevel + 1)
      str += `${indent}};\n`
    } else {
      // str += `${indent}/**\n`
      // str += `${indent} * ${JSON.stringify(obj[key])}\n`
      // str += `${indent} */\n`
      let propertyType = Array.isArray(obj[key]) ? 'unknown[]' : typeof obj[key]
      if (propertyType === 'function') {
        propertyType = '() => string'
      }
      str += `${indent}"${key}": ${propertyType};\n`
    }
  }
  return str
}

const MERGED_OPTIONS_ENDPOINT = '__nuxt_i18n/merged'

export function prepareTypeGeneration(
  { resolver, options, localeInfo, vueI18nConfigPaths, isDev }: I18nNuxtContext,
  nuxt: Nuxt
) {
  if (options.experimental.typedOptionsAndMessages === false || !isDev) return

  addServerHandler({
    route: '/' + MERGED_OPTIONS_ENDPOINT,
    // @ts-ignore
    handler: resolver.resolve('./runtime/server/api/merged-options.get')
  })

  let res: Pick<I18nOptions, 'messages' | 'numberFormats' | 'datetimeFormats'>

  const fetchMergedOptions = () => fetch(nuxt.options.devServer.url + MERGED_OPTIONS_ENDPOINT, { cache: 'no-cache' })
  const localePaths = localeInfo.flatMap(x => x.files.map(f => relative(nuxt.options.srcDir, f.path)))

  async function fetchAndUpdateTypes() {
    res = (await (await fetchMergedOptions()).json()) as Pick<
      I18nOptions,
      'messages' | 'numberFormats' | 'datetimeFormats'
    >
    await updateTemplates({ filter: template => template.filename === 'types/i18n-messages.d.ts' })
  }

  addTypeTemplate({
    filename: 'types/i18n-messages.d.ts',
    getContents: () => {
      if (res == null) return ''

      return `// generated by @nuxtjs/i18n
import type { DateTimeFormatOptions, NumberFormatOptions, SpecificNumberFormatOptions, CurrencyNumberFormatOptions } from '@intlify/core'

interface GeneratedLocaleMessage {
  ${generateInterface(res.messages || {}).trim()}
}

interface GeneratedDateTimeFormat {
  ${Object.keys(res.datetimeFormats || {})
    .map(k => `${k}: DateTimeFormatOptions;`)
    .join(`\n  `)}
}

interface GeneratedNumberFormat {
  ${Object.entries(res.numberFormats || {})
    .map(([k]) => `${k}: NumberFormatOptions;`)
    .join(`\n  `)}
}

declare module 'vue-i18n' {
  export interface DefineLocaleMessage extends GeneratedLocaleMessage {}
  export interface DefineDateTimeFormat extends GeneratedDateTimeFormat {}
  export interface DefineNumberFormat extends GeneratedNumberFormat {}
}

declare module '@intlify/core' {
  export interface DefineCoreLocaleMessage extends GeneratedLocaleMessage {}
}

export {}`
    }
  })

  // setup watcher when using restructureDir - folders outside srcDir are not watched
  if (nuxt.options.future?.compatibilityVersion === 4 || options.restructureDir === false) {
    const watcher = chokidarWatch(
      localeInfo.flatMap(x => x.files.map(f => resolve(nuxt.options.srcDir, f.path))),
      {
        awaitWriteFinish: true,
        ignoreInitial: true,
        ignored: [isIgnored, 'node_modules']
      }
    )

    // eslint-disable-next-line @typescript-eslint/no-misused-promises, @typescript-eslint/no-unsafe-argument
    watcher.on('all', (event, path) => nuxt.callHook('builder:watch', event, normalize(path)))
    nuxt.hook('close', () => watcher?.close())
  }

  /**
   * We use a runtime server endpoint to retrieve and merge options,
   * to reuse existing options/message loading logic
   *
   * These hooks have been the most reliable way to fetch on startup when the endpoint is ready
   */
  addVitePlugin(
    {
      name: 'i18n:type-generation-hmr',
      configureServer() {
        const nitro = useNitro()

        // generate on nitro server start
        nitro.hooks.hookOnce('dev:reload', fetchAndUpdateTypes)

        // watch locale and vue-i18n config file changes
        nuxt.hook('builder:watch', (_, path) => {
          // compatibility see https://nuxt.com/docs/getting-started/upgrade#absolute-watch-paths-in-builderwatch
          // TODO: consider conditionally checking absolute paths for Nuxt 4
          path = relative(nuxt.options.srcDir, resolve(nuxt.options.srcDir, path))

          if (!localePaths.includes(path) && !vueI18nConfigPaths.some(x => x.absolute.includes(path))) return

          // fetch and update types when nitro server is ready
          nitro.hooks.hookOnce('dev:reload', fetchAndUpdateTypes)
        })
      }
    },
    { client: false }
  )
}
